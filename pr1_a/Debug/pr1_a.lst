
pr1_a.elf:     file format elf32-littleriscv
pr1_a.elf
architecture: riscv:rv32, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000040 memsz 0x00000040 flags r-x
    LOAD off    0x00000000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000000 memsz 0x00000008 flags rw-

Sections:
Idx Name              Size      VMA       LMA       File off  Algn  Flags
  0 .text             00000040  00000000  00000000  00001000  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss              00000008  00010000  00010000  00002000  2**0  ALLOC
  2 .riscv.attributes 0000001f  00000000  00000000  00001040  2**0  CONTENTS, READONLY
  3 .debug_line       0000008b  00000000  00000000  0000105f  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
  4 .debug_info       00000026  00000000  00000000  000010ea  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_abbrev     00000014  00000000  00000000  00001110  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_aranges    00000020  00000000  00000000  00001128  2**3  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_str        00000067  00000000  00000000  00001148  2**0  CONTENTS, READONLY, DEBUGGING, OCTETS
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00010000 l    d  .bss	00000000 .bss
00000000 l    d  .riscv.attributes	00000000 .riscv.attributes
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    df *ABS*	00000000 ./pr1_a.o
0000000a l       *ABS*	00000000 N
00010000 l       .bss	00000000 res
00010004 l       .bss	00000000 i
00000024 l       .text	00000000 for
0000003c l       .text	00000000 efor
00000000 g       .text	00000000 main
00020000 g       *ABS*	00000000 _stack



Disassembly of section .text:

00000000 <main>:
main():
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:33
	i: .space 4
//programa
.text
.global main
main:
	la t0, res // t0 guarda la direccion de res
   0:	00010297          	auipc	t0,0x10
   4:	00028293          	mv	t0,t0
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:34
	sw x0, 0(t0) // guardamos el valor inicial de res
   8:	0002a023          	sw	zero,0(t0) # 10000 <res>
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:35
	lw s2, 0(t0) // s2 almacena el valor de res. Seria mas eficiente cargando el 0 como inmediato
   c:	0002a903          	lw	s2,0(t0)
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:36
	la t1, i // t1 guarda la direccion de i
  10:	00010317          	auipc	t1,0x10
  14:	ff430313          	addi	t1,t1,-12 # 10004 <i>
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:37
	sw x0, 0(t1) // guardamos el valor inicial de i
  18:	00032023          	sw	zero,0(t1)
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:38
	lw s3, 0(t1) // s3 almacena el valor de i. Seria mas eficiente cargando el 0 como inmediato
  1c:	00032983          	lw	s3,0(t1)
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:39
	li s1, N
  20:	00a00493          	li	s1,10

00000024 <for>:
for():
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:41
for:
	bge s3, s1, efor
  24:	0099dc63          	bge	s3,s1,3c <efor>
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:42
	add s2, s2, s3 // hacemos res += i
  28:	01390933          	add	s2,s2,s3
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:43
	sw s2, 0(t0) // lo optimo seria guardar solo al final para no acceder todo el rato a la memoria. Como no hemos modificado t0 la direccion de memoria sigue guardada ahi.
  2c:	0122a023          	sw	s2,0(t0)
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:44
	addi s3, s3, 1 // hacemos i++
  30:	00198993          	addi	s3,s3,1
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:45
	sw s3, 0(t1) // lo optimo seria guardar solo al final para no acceder todo el rato a la memoria. Como no hemos modificado t1 la direccion de memoria sigue guardada ahi.
  34:	01332023          	sw	s3,0(t1)
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:46
	j for
  38:	fedff06f          	j	24 <for>

0000003c <efor>:
efor():
C:\Users\radze\Documents\Universidad\Computadores2\FC2practicasWS\pr1_a\Debug/../pr1_a.asm:48
efor:
	j efor
  3c:	0000006f          	j	3c <efor>
